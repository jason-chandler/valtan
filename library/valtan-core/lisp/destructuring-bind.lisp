#+valtan
(in-package :common-lisp)
#-valtan
(in-package :valtan-core)

(defun %db-length (list)
  (do ((l list (cdr l))
       (count 0 (+ count 1)))
      ((atom l) count)))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defvar *db-bindings*)
  (defvar *tmp-db-vars*)
  (defun parse-db-lambda-list (lambda-list arg)
    (macrolet ((%push (x common-lisp:list)
                 `(setq ,common-lisp:list (common-lisp:cons ,x ,common-lisp:list)))
               (%pop (common-lisp:list)
                 `(common-lisp:prog1 (common-lisp:car ,common-lisp:list) (setq ,common-lisp:list (common-lisp:cdr ,common-lisp:list))))
               (%incf (var &optional (n 1))
                 `(setq ,var (common-lisp:+ ,var ,n))))
      (flet ((db-gensym ()
               (common-lisp:car
                (%push
                 (common-lisp:gensym)
                 *tmp-db-vars*)))
             (make-keyword (x)
               (common-lisp:intern (common-lisp:string x) :keyword))
             (invalid-lambda-list ()
               (common-lisp:error "Invalid lambda list: ~S" lambda-list)))
        (let ((path arg)
              (common-lisp:min 0)
              (common-lisp:max 0)
              (state nil)
              (optionalp nil)
              (restp nil)
              (keyp nil)
              (keys nil)
              (allow-other-keys-p nil)
              (check-arg-placeholder)
              (check-key-placeholder))
          (%push (setq check-arg-placeholder (common-lisp:list (db-gensym) nil)) *db-bindings*)
          (common-lisp:when (eq 'common-lisp:&whole (common-lisp:first lambda-list))
            (%pop lambda-list)
            (common-lisp:unless lambda-list (invalid-lambda-list))
            (%push (common-lisp:list (%pop lambda-list) arg) *db-bindings*))
          (common-lisp:do ((ll lambda-list (common-lisp:rest ll)))
                 ((common-lisp:atom ll) (common-lisp:when ll (setq restp t) (%push (common-lisp:list ll path) *db-bindings*)))
            (let ((x (common-lisp:first ll)))
              (common-lisp:cond
               ((eq state :aux)
                (common-lisp:cond ((symbolp x) (%push (common-lisp:list x nil) *db-bindings*))
                         ((common-lisp:consp x)
                          (common-lisp:case (common-lisp:length x)
                            ((1 2) (%push (common-lisp:list (common-lisp:first x) (common-lisp:second x)) *db-bindings*))
                            (common-lisp:otherwise (invalid-lambda-list))))
                         (t (invalid-lambda-list))))
               ((eq x 'common-lisp:&aux) (setq state :aux))
               ((eq x 'common-lisp:&allow-other-keys) (common-lisp:unless (eq state :key) (invalid-lambda-list))
                (setq allow-other-keys-p t))
               ((eq x 'common-lisp:&key) (common-lisp:when keyp (invalid-lambda-list))
                (%push (setq check-key-placeholder (common-lisp:list (db-gensym) path)) *db-bindings*)
                (setq state :key) (setq keyp t))
               ((eq state :key) (%incf common-lisp:max 2)
                (common-lisp:cond
                 ((symbolp x)
                  (let ((key (make-keyword x)))
                    (%push key keys)
                    (%push (common-lisp:list x `(common-lisp:getf ,path ,key)) *db-bindings*)))
                 ((common-lisp:consp x)
                  (let ((len (common-lisp:length x)))
                    (common-lisp:cond
                     ((common-lisp:<= 1 len 3)
                      (let ((key (make-keyword (common-lisp:first x))))
                        (%push key keys)
                        (let ((supplied-value (db-gensym)) (default ''#:default))
                          (%push (common-lisp:list supplied-value `(common-lisp:getf ,path ,key ,default))
                           *db-bindings*)
                          (common-lisp:when (common-lisp:= len 3)
                            (%push (common-lisp:list (common-lisp:third x) `(not (eq ,supplied-value ,default)))
                             *db-bindings*))
                          (%push
                           (common-lisp:list (common-lisp:first x)
                                    `(if (eq ,supplied-value ,default)
                                         ,(common-lisp:second x)
                                         ,supplied-value))
                           *db-bindings*))))
                     (t (invalid-lambda-list)))))
                 (t (invalid-lambda-list))))
               ((common-lisp:member x '(&rest &body)) (setq restp t)
                (common-lisp:cond
                 ((common-lisp:and (common-lisp:rest ll) (symbolp (common-lisp:second ll)))
                  (%push (common-lisp:list (common-lisp:second ll) path) *db-bindings*) (%pop ll))
                 ((common-lisp:and (common-lisp:rest ll) (common-lisp:consp (common-lisp:second ll)))
                  (let ((tmp (db-gensym)))
                    (%push (common-lisp:list tmp path) *db-bindings*)
                    (parse-db-lambda-list (common-lisp:second ll) tmp)))
                 (t (invalid-lambda-list))))
               ((eq x '&optional) (common-lisp:when optionalp (invalid-lambda-list)) (setq state :optional)
                (setq optionalp t))
               ((eq state :optional) (%incf common-lisp:max)
                (common-lisp:cond
                 ((symbolp x) (%push (common-lisp:list x `(common-lisp:first ,path)) *db-bindings*)
                  (let ((cdr-var (db-gensym)))
                    (%push (common-lisp:list cdr-var `(common-lisp:rest ,path)) *db-bindings*)
                    (setq path cdr-var)))
                 ((common-lisp:consp x)
                  (let ((len (common-lisp:length x)))
                    (common-lisp:cond
                     ((common-lisp:<= 1 len 3)
                      (common-lisp:when (common-lisp:= len 3)
                        (%push
                         (common-lisp:list (common-lisp:third x)
                                  `(if ,path
                                       t
                                       nil))
                         *db-bindings*))
                      (%push
                       (common-lisp:list (common-lisp:first x)
                                `(if ,path
                                     (common-lisp:first ,path)
                                     ,(common-lisp:second x)))
                       *db-bindings*)
                      (let ((cdr-var (db-gensym)))
                        (%push (common-lisp:list cdr-var `(common-lisp:rest ,path)) *db-bindings*)
                        (setq path cdr-var)))
                     (t (invalid-lambda-list)))))
                 (t (invalid-lambda-list))))
               ((common-lisp:listp x) (%incf common-lisp:min) (%incf common-lisp:max)
                (let ((car-var (db-gensym)))
                  (%push (common-lisp:list car-var `(common-lisp:first ,path)) *db-bindings*)
                  (parse-db-lambda-list x car-var))
                (let ((cdr-var (db-gensym)))
                  (%push (common-lisp:list cdr-var `(common-lisp:rest ,path)) *db-bindings*)
                  (setq path cdr-var)))
               (t (common-lisp:unless (symbolp x) (invalid-lambda-list)) (%incf common-lisp:min) (%incf common-lisp:max)
                (%push (common-lisp:list x `(common-lisp:first ,path)) *db-bindings*)
                (let ((cdr-var (db-gensym)))
                  (%push (common-lisp:list cdr-var `(common-lisp:rest ,path)) *db-bindings*)
                  (setq path cdr-var))))))
          (common-lisp:rplaca (common-lisp:cdr check-arg-placeholder)
                     `(common-lisp:unless
                          ,(if (common-lisp:or restp keyp)
                               `(common-lisp:<= ,common-lisp:min (%db-length ,arg))
                               `(common-lisp:<= ,common-lisp:min (%db-length ,arg) ,common-lisp:max))
                        (common-lisp:error "Invalid number of arguments for destructuring-bind: ~S ~S"
                                  ',lambda-list ,arg)))
          (common-lisp:when (common-lisp:and check-key-placeholder (common-lisp:not allow-other-keys-p))
            (common-lisp:rplaca (common-lisp:cdr check-key-placeholder)
                       (let ((plist (common-lisp:gensym)))
                         `(common-lisp:do ((,plist ,(common-lisp:second check-key-placeholder) (common-lisp:cddr ,plist)))
                                 ((common-lisp:null ,plist))
                            (common-lisp:unless
                                (common-lisp:or
                                 ,@(common-lisp:mapcar (lambda (key) `(eq ,key (common-lisp:first ,plist))) keys))
                              (common-lisp:error "Unknown &key argument: ~S" (common-lisp:first ,plist)))))))))))
  (defun expand-destructuring-bind (lambda-list expression body)
    (let ((*db-bindings* 'nil) (*tmp-db-vars* 'nil) (g-expression (common-lisp:gensym)))
      (parse-db-lambda-list lambda-list g-expression)
      `(let ((,g-expression ,expression))
         (let* ,(common-lisp:nreverse *db-bindings*)
           (declare (common-lisp:ignorable . ,*tmp-db-vars*))
           ,@body)))))

(*:defmacro* destructuring-bind (lambda-list expression &rest body)
  (expand-destructuring-bind lambda-list expression body))
